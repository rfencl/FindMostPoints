<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PlotPoints</title>
  </head>
  <body>
    <canvas id="DemoCanvas"></canvas>
    <script>
      const canvas = document.getElementById('DemoCanvas');
      const numScaleMarks = 100;
      const numPoints = 100;
      //Always check for properties and methods, to make sure your code doesn't break in other browsers.
      if (canvas.getContext) {
        // Set the screen up
        var vw = Math.max(
          document.documentElement.clientWidth,
          window.innerWidth || 0
        );
        var vh = Math.max(
          document.documentElement.clientHeight,
          window.innerHeight || 0
        );
        var context = canvas.getContext('2d');
        canvas.height = vh;
        canvas.width = vh;
        var centerX = canvas.width / 2;
        var centerY = canvas.height / 2;

        drawAxis();

        let points = generatePoints(numPoints);
        plotPoints(points);
        console.log(JSON.stringify(points)); // Use this to capture a static set of data.

        const slopePointMap = calcSlopes(points);
        // map(key -> set(points))
        const slopeYinterceptPointMap = calcYIntercepts(slopePointMap);

        plotLargestGroup(slopeYinterceptPointMap);
      }

      function plotLargestGroup(slopeYinterceptPointMap) {
        
        const [largest, largestKey] = findLargestSetSize(slopeYinterceptPointMap);
        for (key of slopeYinterceptPointMap.keys()) {
          if (slopeYinterceptPointMap.get(key).size < largest) {
            slopeYinterceptPointMap.delete(key);
          }
        }

        console.log(slopeYinterceptPointMap);
        for (key of slopeYinterceptPointMap.keys()) {
          //console.log(key, slopeYinterceptPointMap.get(key));
          // console.log(slopeYinterceptPointMap.get(key).values());
          const points = [...slopeYinterceptPointMap.get(key)];
          // console.log(points);
          while (points.length > 1) {
            // console.log(point);
            console.log('drawing line from', points[0], points[1]);
            const [p1, p2] = transpose(points[0], points[1]);
            drawLine(p1, p2, '#00ff00', 3);
            points.shift();
            //console.log(points);
          }
        }
      }

      function findLargestSetSize(slopeYinterceptPointMap) {
        let largest = -1;
        let largestKey = '';
        for (key of slopeYinterceptPointMap.keys()) {
          let tlargest = Math.max(
            largest,
            slopeYinterceptPointMap.get(key).size
          );
          if (tlargest > largest) {
            largestKey = key;
            largest = tlargest;
          }
        }
        return [largest, largestKey];
      }

      //scale the point to the screen
      function transpose(p1, p2) {
        return [
          {
            x: centerX + (p1.x * vh) / numScaleMarks,
            y: (p1.y * -vh) / numScaleMarks + vh / 2,
          },
          {
            x: centerX + (p2.x * vh) / numScaleMarks,
            y: (p2.y * -vh) / numScaleMarks + vh / 2,
          },
        ];
      }

      // Return a map of points grouped by slope-y-intercept
      function calcYIntercepts(slopePointMap) {
        let slopeYinterceptMap = new Map();
        for (slope of slopePointMap.keys()) {
          const lineSegments = slopePointMap.get(slope);
          for (points of lineSegments) {
            let newKey = slope + '|' + (-1 * points[0].x * slope + points[0].y);
            addPointsToMap(newKey, slopeYinterceptMap, points);
          }
        }
        return slopeYinterceptMap;
      }

      function addPointsToMap(newKey, slopeYinterceptMap, points) {
        let pointSet = slopeYinterceptMap.has(newKey)
          ? slopeYinterceptMap.get(newKey)
          : new Set();

        addPointToSet(pointSet, points[0]);
        addPointToSet(pointSet, points[1]);
        slopeYinterceptMap.set(newKey, pointSet);
      }

      /*
       * check for point objects filter dups
       */
      function addPointToSet(pointSet, point) {
        const apoints = [...pointSet];
        const index = apoints.findIndex(
          (e) => e.x == point.x && e.y == point.y
        );
        if (index === -1) {
          pointSet.add(point);
        }
      }
      // return a map of points grouped by slope
      function calcSlopes(points) {
        let slopeMap = new Map();
        const lineSegments = [];
        for (i = 0; i < points.length; ++i) {
          for (j = i + 1; j < points.length; ++j) {
            lineSegments.push([points[i], points[j]]);
          }
        }
        for (points of lineSegments) {
          const slope =
            (points[1].y - points[0].y) / (points[1].x - points[0].x);
          let pointList = slopeMap.has(slope) ? slopeMap.get(slope) : [];
          pointList.push(points);
          if (isFinite(slope)) {
            slopeMap.set(slope, pointList);
          }
        }
        return slopeMap;
      }

      // generate a set of points
      function generatePoints(numPoints) {
        var points = [];
        for (i = 0; i < numPoints; ++i) {
          //  const xval = (getSign() * Math.random() * numScaleMarks) / 2;
          //  const yval = (getSign() * Math.random() * numScaleMarks) / 2;
          const xval = getSign() * getRandomInt(numScaleMarks / 2);
          const yval = getSign() * getRandomInt(numScaleMarks / 2);
          //console.log(xval, yval);
          points.push({ x: xval, y: yval });
        }
        return points;
      }

      // randomly pick the quadrant for this point
      function getSign() {
        return (1 + getRandomInt(2)) % 2 == 0 ? -1 : 1;
      }

      // Return an integer between 0 and max
      function getRandomInt(max) {
        return Math.floor(Math.random() * Math.floor(max));
      }

      // plot array of points to plane
      function plotPoints(points) {
        points.map((e) => plotPoint(e));
      }

      // plot point on plane
      function plotPoint(point) {
        const x = centerX + (point.x * vh) / numScaleMarks;
        const y = (point.y * -vh) / numScaleMarks + vh / 2;
        var pointSize = 3;
        context.fillStyle = '#ff2626';

        context.beginPath();
        context.arc(x, y, pointSize, 0, Math.PI * 2, true);
        context.fill();
      }

      // x,y is the center of the screen
      function drawAxis() {
        // main lines
        drawLine({ x: 0, y: centerY }, { x: vh, y: centerY });
        drawLine({ x: centerX, y: 0 }, { x: centerX, y: vh });

        drawHashes();
      }

      function drawHashes() {
        const hashsize = 3;
        for (i = 0; i < numScaleMarks; ++i) {
          let yaxisPoint = { x: centerX, y: i * (vh / numScaleMarks) };
          if (centerY !== yaxisPoint.y) {
            drawLine(
              { x: yaxisPoint.x - hashsize, y: yaxisPoint.y },
              { x: yaxisPoint.x + hashsize, y: yaxisPoint.y }
            );
          }
        }

        for (i = 0; i < numScaleMarks; ++i) {
          let xaxisPoint = { x: i * (vh / numScaleMarks), y: centerY };
          if (centerX !== xaxisPoint.x) {
            drawLine(
              { x: xaxisPoint.x, y: xaxisPoint.y - hashsize },
              { x: xaxisPoint.x, y: xaxisPoint.y + hashsize }
            );
          }
        }
      }

      // Draws a line between points
      function drawLine(p1, p2, color = 'black', width = 1) {
        // Reset the current path
        context.beginPath();
        context.moveTo(p1.x, p1.y);
        context.lineTo(p2.x, p2.y);
        context.lineWidth = width;
        context.strokeStyle = color;
        // Make the line visible
        context.stroke();
      }
    </script>
  </body>
</html>
