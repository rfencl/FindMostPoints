<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PlotPoints</title>
  </head>
  <body>
    <canvas id="DemoCanvas"></canvas>
    <script>
      const canvas = document.getElementById('DemoCanvas');
      const numScaleMarks = 100;
      //Always check for properties and methods, to make sure your code doesn't break in other browsers.
      if (canvas.getContext) {
        // Set the screen up
        var vw = Math.max(
          document.documentElement.clientWidth,
          window.innerWidth || 0
        );
        var vh = Math.max(
          document.documentElement.clientHeight,
          window.innerHeight || 0
        );
        var context = canvas.getContext('2d');
        canvas.height = vh;
        canvas.width = vh;
        var centerX = canvas.width / 2;
        var centerY = canvas.height / 2;

        drawAxis();

        let points = generatePoints(30);
        // let points = [
        //   { x: 14, y: 13 },
        //   { x: -2, y: -16 },
        //   { x: 0, y: -8 },
        //   { x: 8, y: -26 },
        //   { x: -20, y: 16 },
        //   { x: 0, y: -7 },
        //   { x: -12, y: -21 },
        //   { x: 24, y: 10 },
        //   { x: -26, y: -11 },
        //   { x: 20, y: 6 },
        //   { x: 7, y: -12 },
        //   { x: 25, y: 22 },
        //   { x: -29, y: -6 },
        //   { x: -11, y: 23 },
        //   { x: -20, y: -12 },
        //   { x: -3, y: -32 },
        //   { x: 30, y: -17 },
        //   { x: 28, y: -4 },
        //   { x: 9, y: 11 },
        //   { x: -10, y: 32 },
        //   { x: 28, y: 30 },
        //   { x: 21, y: 30 },
        //   { x: 29, y: 31 },
        //   { x: 16, y: 7 },
        //   { x: -7, y: -30 },
        //   { x: 28, y: 8 },
        //   { x: 12, y: 20 },
        //   { x: 13, y: -31 },
        //   { x: -32, y: -6 },
        //   { x: -32, y: 32 },
        // ];

        plotPoints(points);
        //console.log(JSON.stringify(points)); // Use this to capture a static set of data.

        const slopePointMap = calcSlopes(points);
        const slopeYinterceptPointMap = calcYIntercepts(slopePointMap);

        plotLargestGroup(slopeYinterceptPointMap);
      }

      function plotLargestGroup(slopeYinterceptPointMap) {
        // for (key of slopeYinterceptPointMap.keys()) {
        //   flatten(slopeYinterceptPointMap);
        // }

        let largest = -1;
        let largestKey = '';
        for (key of slopeYinterceptPointMap.keys()) {
          let tlargest = Math.max(
            largest,
            slopeYinterceptPointMap.get(key).length
          );
          if (tlargest > largest) {
            largestKey = key;
            largest = tlargest;
          }
        }

        for (key of slopeYinterceptPointMap.keys()) {
          if (slopeYinterceptPointMap.get(key).length < largest) {
            slopeYinterceptPointMap.delete(key);
          }
        }
        for (key of slopeYinterceptPointMap.keys()) {
          console.log(key, slopeYinterceptPointMap.get(key));
          // need to flatten this to count the actual number of points
          for (const segment of slopeYinterceptPointMap.get(key)) {
            const [p1, p2] = transpose(segment[0], segment[1]);
            drawLine(p1, p2);
          }
        }
      }
      // Convert from map(key, [[],[]]) to map(key, [])
      function flatten(slopeYinterceptPointMap) {
        for (key of slopeYinterceptPointMap.keys()) {
          const s = new Set();
          for (const segment of slopeYinterceptPointMap.get(key)) {
            const [p1, p2] = segment;
            s.add(p1, p2);
            slopeYinterceptPointMap.delete(key);
            slopeYinterceptPointMap.set(key, ...s.values());
            //console.log(s.values());
            console.log(key, slopeYinterceptPointMap.get(key));
          }
        }
      }
      //scale the point to the screen
      function transpose(p1, p2) {
        return [
          {
            x: centerX + (p1.x * vh) / numScaleMarks,
            y: (p1.y * -vh) / numScaleMarks + vh / 2,
          },
          {
            x: centerX + (p2.x * vh) / numScaleMarks,
            y: (p2.y * -vh) / numScaleMarks + vh / 2,
          },
        ];
      }

      // Return a map of points grouped by slope-y-intercept
      function calcYIntercepts(slopePointMap) {
        let slopeYinterceptMap = new Map();
        for (key of slopePointMap.keys()) {
          const lineSegments = slopePointMap.get(key);
          for (points of lineSegments) {
            let point = points[0]; // we only need the y-int for one point in the pair.
            const yIntercept = 0 === key ? point.y : (point.y - point.x) / key;
            let newKey = key + '|' + yIntercept;
            let pointList = slopeYinterceptMap.has(newKey)
              ? slopeYinterceptMap.get(newKey)
              : [];
            pointList.push(points);
            slopeYinterceptMap.set(newKey, pointList);
          }
        }
        return slopeYinterceptMap;
      }

      // return a map of points grouped by slope
      function calcSlopes(points) {
        let slopeMap = new Map();
        const lineSegments = [];
        for (i = 0; i < points.length; ++i) {
          for (j = i + 1; j < points.length; ++j) {
            lineSegments.push([points[i], points[j]]);
          }
        }
        for (points of lineSegments) {
          const slope =
            (points[1].y - points[0].y) / (points[1].x - points[0].x);
          let pointList = slopeMap.has(slope) ? slopeMap.get(slope) : [];
          pointList.push(points);
          if (isFinite(slope)) {
            slopeMap.set(slope, pointList);
          }
        }
        return slopeMap;
      }

      // generate a set of points
      function generatePoints(numPoints) {
        var points = [];
        for (i = 0; i < numPoints; ++i) {
          //  const xval = (getSign() * Math.random() * numScaleMarks) / 2;
          //  const yval = (getSign() * Math.random() * numScaleMarks) / 2;
          const xval = getSign() * getRandomInt(numScaleMarks / 3);
          const yval = getSign() * getRandomInt(numScaleMarks / 3);
          //console.log(xval, yval);
          points.push({ x: xval, y: yval });
        }
        return points;
      }

      // randomly pick the quadrant for this point
      function getSign() {
        return (1 + getRandomInt(2)) % 2 == 0 ? -1 : 1;
      }

      // Return an integer between 0 and max
      function getRandomInt(max) {
        return Math.floor(Math.random() * Math.floor(max));
      }

      // plot array of points to plane
      function plotPoints(points) {
        points.map((e) => plotPoint(e));
      }

      // plot point on plane
      function plotPoint(point) {
        const x = centerX + (point.x * vh) / numScaleMarks;
        const y = (point.y * -vh) / numScaleMarks + vh / 2;
        var pointSize = 3;
        context.fillStyle = '#ff2626';

        context.beginPath();
        context.arc(x, y, pointSize, 0, Math.PI * 2, true);
        context.fill();
      }

      // x,y is the center of the screen
      function drawAxis() {
        // main lines
        drawLine({ x: 0, y: centerY }, { x: vh, y: centerY });
        drawLine({ x: centerX, y: 0 }, { x: centerX, y: vh });

        drawHashes();
      }

      function drawHashes() {
        const hashsize = 3;
        for (i = 0; i < numScaleMarks; ++i) {
          let yaxisPoint = { x: centerX, y: i * (vh / numScaleMarks) };
          if (centerY !== yaxisPoint.y) {
            drawLine(
              { x: yaxisPoint.x - hashsize, y: yaxisPoint.y },
              { x: yaxisPoint.x + hashsize, y: yaxisPoint.y }
            );
          }
        }

        for (i = 0; i < numScaleMarks; ++i) {
          let xaxisPoint = { x: i * (vh / numScaleMarks), y: centerY };
          if (centerX !== xaxisPoint.x) {
            drawLine(
              { x: xaxisPoint.x, y: xaxisPoint.y - hashsize },
              { x: xaxisPoint.x, y: xaxisPoint.y + hashsize }
            );
          }
        }
      }

      // Draws a line between points
      function drawLine(p1, p2) {
        // Reset the current path
        context.beginPath();
        context.moveTo(p1.x, p1.y);
        context.lineTo(p2.x, p2.y);
        // Make the line visible
        context.stroke();
      }
    </script>
  </body>
</html>
