<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>PlotPoints</title>
  </head>
  <body>
    <canvas id="DemoCanvas"></canvas>
    <script>
      const canvas = document.getElementById('DemoCanvas');
      const numScaleMarks = 100;
      //Always check for properties and methods, to make sure your code doesn't break in other browsers.
      if (canvas.getContext) {
        // Set the screen up
        var vw = Math.max(
          document.documentElement.clientWidth,
          window.innerWidth || 0
        );
        var vh = Math.max(
          document.documentElement.clientHeight,
          window.innerHeight || 0
        );
        var context = canvas.getContext('2d');
        canvas.height = vh;
        canvas.width = vh;
        var centerX = canvas.width / 2;
        var centerY = canvas.height / 2;

        drawAxis();

        let points = generatePoints(30);
        // let points = [
        //   { x: 16, y: 1 },
        //   { x: 21, y: 27 },
        //   { x: -2, y: 27 },
        //   { x: -20, y: -22 },
        //   { x: -32, y: 14 },
        //   { x: -22, y: 2 },
        //   { x: -28, y: 8 },
        //   { x: 1, y: -18 },
        //   { x: -24, y: 2 },
        //   { x: -10, y: 19 },
        //   { x: 8, y: -4 },
        //   { x: -8, y: -11 },
        //   { x: 28, y: -24 },
        //   { x: 29, y: 3 },
        //   { x: 26, y: 22 },
        //   { x: -29, y: 23 },
        //   { x: 30, y: 27 },
        //   { x: -19, y: 8 },
        //   { x: -29, y: 12 },
        //   { x: -31, y: 9 },
        //   { x: 27, y: -16 },
        //   { x: -21, y: 19 },
        //   { x: -27, y: -8 },
        //   { x: -1, y: -14 },
        //   { x: 6, y: 20 },
        //   { x: -4, y: 27 },
        //   { x: 11, y: 16 },
        //   { x: -27, y: 22 },
        //   { x: 29, y: -7 },
        //   { x: 19, y: -12 },
        // ];

        plotPoints(points);
        // console.log(JSON.stringify(points)); // Use this to capture a static set of data.

        const slopePointMap = calcSlopes(points);
        // map(key -> set(points))
        const slopeYinterceptPointMap = calcYIntercepts(slopePointMap);

        plotLargestGroup(slopeYinterceptPointMap);
      }

      function plotLargestGroup(slopeYinterceptPointMap) {
        let largest = -1;
        let largestKey = '';
        for (key of slopeYinterceptPointMap.keys()) {
          let tlargest = Math.max(
            largest,
            slopeYinterceptPointMap.get(key).size
          );
          if (tlargest > largest) {
            largestKey = key;
            largest = tlargest;
          }
        }

        for (key of slopeYinterceptPointMap.keys()) {
          if (slopeYinterceptPointMap.get(key).size < largest) {
            slopeYinterceptPointMap.delete(key);
          }
        }
        console.log(slopeYinterceptPointMap);
        for (key of slopeYinterceptPointMap.keys()) {
          console.log(key, slopeYinterceptPointMap.get(key));
          // console.log(slopeYinterceptPointMap.get(key).values());
          const points = [...slopeYinterceptPointMap.get(key).values()];
          // console.log(points);
          for (const point of points) {
            // console.log(point);
            if (points.length > 1) {
              console.log('drawing line from', points[0], points[1]);
              const [p1, p2] = transpose(points[0], points[1]);
              drawLine(p1, p2);
              points.shift();
              console.log(points);
            }
          }
        }
      }

      //scale the point to the screen
      function transpose(p1, p2) {
        return [
          {
            x: centerX + (p1.x * vh) / numScaleMarks,
            y: (p1.y * -vh) / numScaleMarks + vh / 2,
          },
          {
            x: centerX + (p2.x * vh) / numScaleMarks,
            y: (p2.y * -vh) / numScaleMarks + vh / 2,
          },
        ];
      }

      // Return a map of points grouped by slope-y-intercept
      function calcYIntercepts(slopePointMap) {
        let slopeYinterceptMap = new Map();
        for (slope of slopePointMap.keys()) {
          const lineSegments = slopePointMap.get(slope);
          for (points of lineSegments) {
            let pointl = points[0]; 
            let pointr = points[1];
            let newKey = slope + '|' + (-1 * pointr.x * slope + pointr.y);
            let pointSet = slopeYinterceptMap.has(newKey)
              ? slopeYinterceptMap.get(newKey)
              : new Set();
            pointSet.add(pointl);
            pointSet.add(pointr);
            slopeYinterceptMap.set(newKey, pointSet);
          }
        }
        return slopeYinterceptMap;
      }

         // return a map of points grouped by slope
      function calcSlopes(points) {
        let slopeMap = new Map();
        const lineSegments = [];
        for (i = 0; i < points.length; ++i) {
          for (j = i + 1; j < points.length; ++j) {
            lineSegments.push([points[i], points[j]]);
          }
        }
        for (points of lineSegments) {
          const slope =
            (points[1].y - points[0].y) / (points[1].x - points[0].x);
          let pointList = slopeMap.has(slope) ? slopeMap.get(slope) : [];
          pointList.push(points);
          if (isFinite(slope)) {
            slopeMap.set(slope, pointList);
          }
        }
        return slopeMap;
      }

      // generate a set of points
      function generatePoints(numPoints) {
        var points = [];
        for (i = 0; i < numPoints; ++i) {
          //  const xval = (getSign() * Math.random() * numScaleMarks) / 2;
          //  const yval = (getSign() * Math.random() * numScaleMarks) / 2;
          const xval = getSign() * getRandomInt(numScaleMarks / 3);
          const yval = getSign() * getRandomInt(numScaleMarks / 3);
          //console.log(xval, yval);
          points.push({ x: xval, y: yval });
        }
        return points;
      }

      // randomly pick the quadrant for this point
      function getSign() {
        return (1 + getRandomInt(2)) % 2 == 0 ? -1 : 1;
      }

      // Return an integer between 0 and max
      function getRandomInt(max) {
        return Math.floor(Math.random() * Math.floor(max));
      }

      // plot array of points to plane
      function plotPoints(points) {
        points.map((e) => plotPoint(e));
      }

      // plot point on plane
      function plotPoint(point) {
        const x = centerX + (point.x * vh) / numScaleMarks;
        const y = (point.y * -vh) / numScaleMarks + vh / 2;
        var pointSize = 3;
        context.fillStyle = '#ff2626';

        context.beginPath();
        context.arc(x, y, pointSize, 0, Math.PI * 2, true);
        context.fill();
      }

      // x,y is the center of the screen
      function drawAxis() {
        // main lines
        drawLine({ x: 0, y: centerY }, { x: vh, y: centerY });
        drawLine({ x: centerX, y: 0 }, { x: centerX, y: vh });

        drawHashes();
      }

      function drawHashes() {
        const hashsize = 3;
        for (i = 0; i < numScaleMarks; ++i) {
          let yaxisPoint = { x: centerX, y: i * (vh / numScaleMarks) };
          if (centerY !== yaxisPoint.y) {
            drawLine(
              { x: yaxisPoint.x - hashsize, y: yaxisPoint.y },
              { x: yaxisPoint.x + hashsize, y: yaxisPoint.y }
            );
          }
        }

        for (i = 0; i < numScaleMarks; ++i) {
          let xaxisPoint = { x: i * (vh / numScaleMarks), y: centerY };
          if (centerX !== xaxisPoint.x) {
            drawLine(
              { x: xaxisPoint.x, y: xaxisPoint.y - hashsize },
              { x: xaxisPoint.x, y: xaxisPoint.y + hashsize }
            );
          }
        }
      }

      // Draws a line between points
      function drawLine(p1, p2) {
        // Reset the current path
        context.beginPath();
        context.moveTo(p1.x, p1.y);
        context.lineTo(p2.x, p2.y);
        // Make the line visible
        context.stroke();
      }
    </script>
  </body>
</html>
